# 算法学习

## Leetcode题解

+ [C++](https://github.com/Simonhancrew/LearningAlgorithm/tree/master/LeetCode/CPP)


+ [PY](https://github.com/Simonhancrew/LearningAlgorithm/tree/master/LeetCode/PY)

## [程序员面试指南](https://github.com/Simonhancrew/LearningAlgorithm/tree/master/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8D%97)
---
+ 一本关于面试常见算法最优解的书，实现代码来自newcoder的算法班.

- [ ] 用C++重写一次

## [自己XJB写的东西](https://github.com/Simonhancrew/LearningAlgorithm/tree/master/XJBX)
---
 - [BloomFilter](https://github.com/Simonhancrew/LearningAlgorithm/tree/master/XJBX/Bloomfilter)
    > 一个参考Cassandra中的BloomFilter实现，Hash选用MurmurHash2，通过双重散列公式生成散列函数
    
    > 参考：http://hur.st/bloomfilter
+ [FundmentalADT](https://github.com/Simonhancrew/XJBX/tree/master/XJBX/FundementalADT)
    > 自己撸的一些数据结构，参考了邓老师的数据结构和Mark Allen的DS

+ [SCL](https://github.com/Simonhancrew/LearningAlgorithm/tree/master/XJBX/SCL)
    > Standard Code Library,平时看到的比较有趣的和可能用得到的代码
    + [Morris遍历](https://github.com/Simonhancrew/LearningAlgorithm/blob/master/XJBX/SCL/Graph/MorrisTraverse.hpp)
        > 一种树的遍历算法，前中序很有趣，基本可以实现O(1)的额外空间复杂度。后序个人觉得没必要，因为有些操作感觉会引入一点额外的时间复杂度。
    
        > 主要是利用了叶子节点的空悬孩子的信息
## [对数器的C++实现](https://github.com/Simonhancrew/LearningAlgorithm/blob/master/XJBX/comparing_figure_device.cpp)
---
